# Cursor Trail / Cursor Follower — Implementation Knowledge

## What Works

### CSS — Critical Properties

```css
.cursor-follower {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 50;
  pointer-events: none;           /* Let clicks pass through */
  will-change: transform;         /* Pre-promote to GPU layer */
  backface-visibility: hidden;    /* Prevent flickering artifacts */

  /* Triple-layer hide: guarantees element is invisible before JS */
  opacity: 0;
  visibility: hidden;
  transform: translate3d(-9999px, -9999px, 0);

  /* Only transition opacity + visibility (compositor-only) */
  transition:
    opacity 0.3s cubic-bezier(0.16, 1, 0.3, 1),
    visibility 0.3s;
}

.cursor-follower.is-visible {
  opacity: 1;
  visibility: visible;
  /* transform is set by JS — don't override it here */
}
```

### JavaScript — Positioning with translate3d

**Always use `transform: translate3d(x, y, 0)` — never `left`/`top`.**

`translate3d` runs on the GPU compositor thread, skipping layout and paint.
`left`/`top` triggers full reflow → repaint → composite on every frame.

```js
// GOOD — compositor only, GPU-accelerated
follower.style.transform = `translate3d(${x}px, ${y}px, 0)`;

// BAD — triggers reflow every frame
follower.style.left = x + "px";
follower.style.top = y + "px";
```

### JavaScript — Lerp Smoothing with Idle Detection

```js
function lerp(a, b, t) { return a + (b - a) * t; }

const SPEED = 0.12;       // 0.1–0.15 = smooth trail, 1.0 = no lag
const THRESHOLD = 0.5;    // Stop rAF when this close (px)

function animate() {
  currentX = lerp(currentX, targetX, SPEED);
  currentY = lerp(currentY, targetY, SPEED);
  follower.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;

  const dx = Math.abs(targetX - currentX);
  const dy = Math.abs(targetY - currentY);

  if (dx > THRESHOLD || dy > THRESHOLD) {
    raf = requestAnimationFrame(animate);
  } else {
    // Snap to final position and stop loop
    currentX = targetX;
    currentY = targetY;
    follower.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
    raf = 0;
  }
}
```

### JavaScript — Lifecycle Events

```js
// mouseenter: snap to position instantly, then start loop
hero.addEventListener("mouseenter", (e) => {
  currentX = targetX = e.clientX;
  currentY = targetY = e.clientY;
  follower.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
  follower.classList.add("is-visible");
  if (!raf) raf = requestAnimationFrame(animate);
});

// mouseleave: fade out, stop loop
hero.addEventListener("mouseleave", () => {
  follower.classList.remove("is-visible");
  if (raf) { cancelAnimationFrame(raf); raf = 0; }
});

// mousemove: only store coordinates, restart loop if idle
hero.addEventListener("mousemove", (e) => {
  targetX = e.clientX;
  targetY = e.clientY;
  if (!raf) raf = requestAnimationFrame(animate);
});
```

### Mobile — Touch-Based Project Preview

On mobile/touch devices, the same follower element is used but driven by
touch events instead of mouse events. The image appears offset above the
finger so it remains visible.

**Why touch instead of tilt (DeviceOrientationEvent):**
- Tilt requires `DeviceOrientationEvent.requestPermission()` on iOS Safari
  (since iOS 13), which shows a permission dialog — bad UX friction.
- Android allows tilt without permission, but iOS is the majority of mobile.
- Touch events are universally supported with zero friction.

**Touch interaction pattern:**
```js
const OFFSET_Y = -180; // px above the touch point

hero.addEventListener("touchstart", (e) => {
  const touch = e.touches[0];
  follower.style.transform =
    `translate3d(${touch.clientX}px, ${touch.clientY + OFFSET_Y}px, 0)`;
  follower.classList.add("is-visible");
  advanceProject(); // Cycle to next project on each touch
}, { passive: true });

hero.addEventListener("touchmove", (e) => {
  const touch = e.touches[0];
  follower.style.transform =
    `translate3d(${touch.clientX}px, ${touch.clientY + OFFSET_Y}px, 0)`;
}, { passive: true });

hero.addEventListener("touchend", () => {
  // Navigate to the shown project
  window.location.href = follower.dataset.href;
  // Fade out
  setTimeout(() => follower.classList.remove("is-visible"), 200);
}, { passive: true });
```

**Mobile CSS (smaller card):**
```css
@media (max-width: 768px) {
  .cursor-project-image-wrap { width: 160px; }
  .cursor-project-title { max-width: 160px; }
}
```

**Detection:** Use `window.matchMedia("(hover: hover)").matches` to branch
between desktop (mouse) and mobile (touch) code paths.

---

## What Does NOT Work

| Approach | Why It Fails |
|---|---|
| `left`/`top` for positioning | Triggers full reflow every frame — janky on 60fps |
| `will-change: left, top` | Counterproductive — hints browser to optimize for layout properties |
| `opacity: 0` alone for hiding | Element still visible if CSS scoping fails or before styles load |
| Continuous rAF loop (no idle check) | Wastes CPU when cursor is stationary |
| Setting `cursor: none` in CSS | Use JS to set it only after confirming hover capability |
| Astro scoped styles on slotted elements | Can be unreliable for dynamic class toggling — prefer `is:global` or inline styles for the follower |

---

## Performance Rules

1. **Only animate `transform` and `opacity`** — these are compositor-only properties
2. **Never call `getBoundingClientRect()`** inside the rAF loop
3. **Stop the rAF loop** when the follower has caught up (idle detection)
4. **Restart the loop** on the next `mousemove` after idle
5. **Keep follower image small** (~220px wide) to minimize GPU texture memory
6. **Preload project images** with `new Image()` for instant swaps

---

## Sources

- 14islands: Developing a Performant Custom Cursor
- Paul Irish: Why translate() Is Better Than top/left
- Smashing Magazine: CSS GPU Animation — Doing It Right
- MDN: will-change, pointer-events, translate3d
